## Realm数据库

#### 使用步骤

#### 优点

1. 性能优秀。

- 相比于传统数据库 链接 - 查询 - 命中 - 内存拷贝 - 对象序列化 的复杂过程，Realm采用基于内存映射的Zero-Copy技术，速度快一个数量级。
- 内部采用了类似git的对象版本管理机制，并发的性能和安全性也不错。

1. 响应式

- Realm的查询结果是随数据库变化实时更新的（要求对象在Run Loop线程中），配合KVO或者Realm自带的ObjectNotification，可以轻松构建及时反映数据变化的响应式UI，这点和目前主流的响应式框架（ReactNative，ReactiveCocoa）应该是天作之和了。但是要求使用者改变思路，不然会出现很多诡异的bug。

1. 简单易用

- Core Data 和 SQLite 冗余、繁杂的知识和代码足以吓退绝大多数刚入门的开发者，而换用 Realm，则可以极大地减少学习成本，立即学会本地化存储的方法。

1. 可视化

- Realm提供了一个轻量级的数据库查看工具，Realm Browser

#### 要注意的坑

1. 多线程问题

- RealmObject自带线程保护功能，传入的context中包含线程的参数。所以只能在创建它的线程中访问，在子线程中不能访问
- 如果你在主线程中new了一个RealmObject对象 user，那么在子线程中是访问不了user对象的。要想在子线程中访问，必须先将user存入Ream中，然后在子线程中query出来。

1. Realm已关闭错误

- 如果Realm关闭，所有查询得到的RealmObject都不能使用了。如果想在子线程中去查询数据，然后在主线程中使用是无法做到的。所以Realm提供的异步查询就很重要了。
- 如果想在Realm.close()之后继续操作查询得到的对象，只能复制一份数据传出来。为防止Realm忘记关闭，个人喜欢将Realm的开启和关闭封装在一个函数中。但是Realm被Colse掉之后，query得到对象就不能访问了，所以只能复制一份数据传出来。

1. 无法修改对象

- query得到的对象需要在Transaction中修改和删除
- 所以对于query出来的对象需要重新new一个进行后续操作

1. 不支持联合主键

- 需要使用联合主键的话，需要自己拼一个新的字段作为Primary Key

1. 对业务代码的侵蚀严重

- 所有的的数据库对象要继承指定的类（没法继承自己的基类了），增删改查，对查询结果处理都有特殊的语法要求，这使得在旧项目中引入Realm或者放弃使用将Realm从项目中剥离都面临很大的成本。无法做成插拔式结构。